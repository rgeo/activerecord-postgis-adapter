name: Tests
on:
  push:
    branches:
      - master
  pull_request:
    types: [opened, reopened, synchronize]
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# This allows a subsequently queued workflow run to interrupt previous runs.
concurrency:
  group: '${{ github.workflow }} @ ${{ github.ref }}'
  cancel-in-progress: true

jobs:
  orchestrate:
    name: Orchestrate matrix from Docker Hub
    runs-on: ubuntu-latest
    outputs:
      postgis_tags: ${{ steps.prepare.outputs.postgis_tags }}
    steps:
      - name: Query Docker Hub tags and build matrix
        id: prepare
        run: |
          # https://www.postgresql.org/support/versioning/
          pg_targets='[14, 15, 16, 17, 18]'

          tags=$(
            curl -s "https://hub.docker.com/v2/repositories/postgis/postgis/tags?page_size=100" |
            jq --compact-output '
              .results
              | map(.name) as $tags
              | '"$pg_targets"'
              | map(
                . as $target
                | $tags
                | map(select(test("^\($target)-\\d+\\.\\d+$")))[0]
              )
            '
          )

          if [[ $(jq 'length' <<< "$tags") -ne $(jq 'length' <<< "$tags") ]]; then
            echo "Error: Could not find tags for all PostgreSQL targets" >&2
            exit 1
          fi

          echo "postgis_tags=$tags" >> $GITHUB_OUTPUT
  test:
    runs-on: ubuntu-latest
    needs: [orchestrate]
    services:
      postgis:
        image: postgis/postgis:${{matrix.pg}}
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --name=postgres
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    strategy:
      fail-fast: false
      matrix:
        # https://ruby-lang.org/en/downloads/branches
        ruby: ['3.4', '3.3', '3.2']
        # https://www.postgresql.org/support/versioning/
        # See (and update!) `pg_targets` above for selected pg versions.
        pg: ${{ fromJson(needs.orchestrate.outputs.postgis_tags) }}
    steps:
      - name: Set Up Actions
        uses: actions/checkout@v4
      - name: Install GEOS
        run: sudo apt-get install libgeos-dev
      - name: Set Up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ matrix.ruby }}
          bundler-cache: true
      - name: Setup Database
        run: |
          for db in activerecord_unittest activerecord_unittest2; do
            psql -d postgresql://postgres:postgres@localhost:5432/postgres \
                 -c "create database $db"
            psql -d postgresql://postgres:postgres@localhost:5432/$db -c "create extension postgis"
          done
      - name: Run Tests
        id: test
        run: bundle exec rake test
        env:
          PGHOST: localhost
          PGUSER: postgres
          PGPASSWORD: postgres
          TESTOPTS: --profile=3
          TEST_TIMEOUT: 30
          RAILS_MINITEST_PLUGIN: '1'
          JSON_REPORTER: 'report.json'
      - name: Upload Report
        if: ${{ failure() && steps.test.conclusion == 'failure' }}
        uses: actions/upload-artifact@v4
        with:
          name: report-${{ matrix.pg }}-${{ matrix.ruby }}
          path: report.json
  # Since the name of the matrix job depends on the version,
  # we define another job with a more stable name. This jobs
  # also gives a nice summary of failing tests.
  test_results:
    if: always()
    runs-on: ubuntu-latest
    name: Test Results
    needs: [test]
    steps:
      - name: Check Success
        run: |
          result="${{ needs.test.result }}"

          if [[ $result == "success" || $result == "skipped" ]]; then
            echo "All tests passed :taco:" >>$GITHUB_STEP_SUMMARY
            exit 0
          else
            exit 1
          fi
      - name: Download Reports
        if: failure()
        uses: actions/download-artifact@v4
        with:
          path: reports
      - name: Aggregate Reports
        if: failure()
        run: |
          cat <<EOF >>$GITHUB_STEP_SUMMARY
          # Failing Tests

          <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Test</th>
              <th>Failure</th>
            </tr>
          </thead>
          <tbody>
          EOF

          jq --slurp --raw-output '
            map(.failed_tests) | flatten | map({
              klass,
              NAME,
              failure: .failures[0],
              source_url: (
                .source_location | if (.[0] | contains("/gems/")) then
                  (.[0] | capture("rails-(?<sha>.*?)/(?<path>.*)")) *
                  {line: .[1], server: "https://github.com", repo: "rails/rails"}
                else
                  (.[0] | capture("activerecord-postgis-adapter/(?<path>test/.*)") *
                  {line: .[1], sha: $ENV.GITHUB_SHA, repo: $ENV.GITHUB_REPOSITORY, server: $ENV.GITHUB_SERVER_URL}
                end | "\(.server)/\(.repo)/blob/\(.sha)/\(.path)#L\(.line)"
              )
            }) | group_by(.) | map(.[0] * { count: length }) | sort[0:100][]
            | "<tr>"
            +   "<td><strong>\(.count)</strong></td>"
            +   "<td><a href=\"\(.source_url)\">\(.klass)#\(.NAME)</a></td>"
            +   "<td><pre>\(.failure)</pre></td>"
            + "</tr>"
          ' reports/*/report.json >>$GITHUB_STEP_SUMMARY

          cat <<EOF >>$GITHUB_STEP_SUMMARY
          </tbody>
          </table>
          EOF

          # Do not print json if too large.
          [[ "$(du -s reports | cut -f1)" -gt 124 ]] && exit 0

          echo >>$GITHUB_STEP_SUMMARY
          echo '```json' >>$GITHUB_STEP_SUMMARY
          jq --slurp --compact-output '.' reports/*/report.json >>$GITHUB_STEP_SUMMARY
          echo '```' >>$GITHUB_STEP_SUMMARY
